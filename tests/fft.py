# Copyright 2021 NVIDIA Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import numpy as np
import warnings
import scipy.signal as sig

import cunumeric as num

def allclose(A, B):
    if(B.dtype==np.float32 or B.dtype == np.complex64):
        l2 = (A - B) * np.conj(A-B)
        l2 = np.sqrt(np.sum(l2)/np.sum(A*np.conj(A)))
        return l2 < 1e-6
    else:
        return np.allclose(A, B)

def test_1d(dtype=np.float64):
    Z     = np.random.rand(1000001).astype(dtype) + np.random.rand(1000001).astype(dtype) * 1j
    Z_num = num.array(Z)

    out       = np.fft.fft(Z)
    out_num   = num.fft.fft(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.fft(Z, norm='forward')
    out_num   = num.fft.fft(Z_num, norm='forward')
    assert allclose(out, out_num)
    out       = np.fft.fft(Z, n=5001)
    out_num   = num.fft.fft(Z_num, n=5001)
    assert allclose(out, out_num)
    out       = np.fft.fft(Z, n=1001001)
    out_num   = num.fft.fft(Z_num, n=1001001)
    assert allclose(out, out_num)
    out       = np.fft.ifft(Z, norm='forward')
    out_num   = num.fft.ifft(Z_num, norm='forward')
    assert allclose(out, out_num)
    out       = np.fft.ifft(Z)
    out_num   = num.fft.ifft(Z_num)
    assert allclose(out, out_num)
    # Odd types
    warnings.filterwarnings(action='ignore', category=np.ComplexWarning)
    out       = np.fft.rfft(Z)
    out_num   = num.fft.rfft(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.ihfft(Z)
    out_num   = num.fft.ihfft(Z_num)
    assert allclose(out, out_num)
    assert allclose(Z, Z_num)

def test_2d(dtype=np.float64):
    Z     = np.random.rand(128, 512).astype(dtype) + np.random.rand(128, 512).astype(dtype) * 1j
    Z_num = num.array(Z)

    out       = np.fft.fft2(Z)
    out_num   = num.fft.fft2(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.fft2(Z, norm='forward')
    out_num   = num.fft.fft2(Z_num, norm='forward')
    assert allclose(out, out_num)
    out       = np.fft.fft2(Z,  s=(64,490))
    out_num   = num.fft.fft2(Z_num, s=(64,490))
    assert allclose(out, out_num)
    out       = np.fft.fft2(Z,  s=(129,600))
    out_num   = num.fft.fft2(Z_num, s=(129,600))
    assert allclose(out, out_num)
    out       = np.fft.fft2(Z,  s=(29,610))
    out_num   = num.fft.fft2(Z_num, s=(29,610))
    assert allclose(out, out_num)
    out       = np.fft.fft2(Z, axes=[0])
    out_num   = num.fft.fft2(Z_num, axes=[0])
    assert allclose(out, out_num)
    out       = np.fft.fft2(Z, axes=[1])
    out_num   = num.fft.fft2(Z_num, axes=[1])
    assert allclose(out, out_num)
    out       = np.fft.fft2(Z, axes=[-1])
    out_num   = num.fft.fft2(Z_num, axes=[-1])
    assert allclose(out, out_num)
    out       = np.fft.fft2(Z, axes=[-2])
    out_num   = num.fft.fft2(Z_num, axes=[-2])
    assert allclose(out, out_num)
    out       = np.fft.fft2(Z, axes=[0, 1])
    out_num   = num.fft.fft2(Z_num, axes=[0, 1])
    assert allclose(out, out_num)
    out       = np.fft.fft2(Z, axes=[1, 0])
    out_num   = num.fft.fft2(Z_num, axes=[1, 0])
    assert allclose(out, out_num)
    out       = np.fft.fft2(Z, axes=[1, 0, 1])
    out_num   = num.fft.fft2(Z_num, axes=[1, 0, 1])
    assert allclose(out, out_num)
    out       = np.fft.ifft2(Z)
    out_num   = num.fft.ifft2(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.ifft2(Z, norm='forward')
    out_num   = num.fft.ifft2(Z_num, norm='forward')
    assert allclose(out, out_num)
    out       = np.fft.ifft2(Z,  s=(64,490))
    out_num   = num.fft.ifft2(Z_num, s=(64,490))
    assert allclose(out, out_num)
    out       = np.fft.ifft2(Z,  s=(129,600))
    out_num   = num.fft.ifft2(Z_num, s=(129,600))
    assert allclose(out, out_num)
    out       = np.fft.ifft2(Z,  s=(29,610))
    out_num   = num.fft.ifft2(Z_num, s=(29,610))
    assert allclose(out, out_num)
    out       = np.fft.ifft2(Z, axes=[0])
    out_num   = num.fft.ifft2(Z_num, axes=[0])
    assert allclose(out, out_num)
    out       = np.fft.ifft2(Z, axes=[1])
    out_num   = num.fft.ifft2(Z_num, axes=[1])
    assert allclose(out, out_num)
    out       = np.fft.ifft2(Z, axes=[-1])
    out_num   = num.fft.ifft2(Z_num, axes=[-1])
    assert allclose(out, out_num)
    out       = np.fft.ifft2(Z, axes=[-2])
    out_num   = num.fft.ifft2(Z_num, axes=[-2])
    assert allclose(out, out_num)
    out       = np.fft.ifft2(Z, axes=[0, 1])
    out_num   = num.fft.ifft2(Z_num, axes=[0, 1])
    assert allclose(out, out_num)
    out       = np.fft.ifft2(Z, axes=[1, 0])
    out_num   = num.fft.ifft2(Z_num, axes=[1, 0])
    assert allclose(out, out_num)
    out       = np.fft.ifft2(Z, axes=[1, 0, 1])
    out_num   = num.fft.ifft2(Z_num, axes=[1, 0, 1])
    assert allclose(out, out_num)
    # Odd types
    out       = np.fft.rfft2(Z)
    out_num   = num.fft.rfft2(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.ihfft(Z)
    out_num   = num.fft.ihfft(Z_num)
    assert allclose(out, out_num)
    assert allclose(Z, Z_num)

def test_3d(dtype=np.float64):
    Z     = np.random.rand(64, 40, 100).astype(dtype) + np.random.rand(64, 40, 100).astype(dtype) * 1j
    Z_num = num.array(Z)

    out       = np.fft.fftn(Z)
    out_num   = num.fft.fftn(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.fftn(Z, norm='forward')
    out_num   = num.fft.fftn(Z_num, norm='forward')
    assert allclose(out, out_num)
    out       = np.fft.fftn(Z, norm='ortho')
    out_num   = num.fft.fftn(Z_num, norm='ortho')
    assert allclose(out, out_num)
    out       = np.fft.fftn(Z, s=(63,20,99))
    out_num   = num.fft.fftn(Z_num, s=(63,20,99))
    assert allclose(out, out_num)
    out       = np.fft.fftn(Z, s=(65,43,109))
    out_num   = num.fft.fftn(Z_num, s=(65,43,109))
    assert allclose(out, out_num)
    out       = np.fft.fftn(Z, axes=[0])
    out_num   = num.fft.fftn(Z_num, axes=[0])
    assert allclose(out, out_num)
    out       = np.fft.fftn(Z, axes=[1])
    out_num   = num.fft.fftn(Z_num, axes=[1])
    assert allclose(out, out_num)
    out       = np.fft.fftn(Z, axes=[2])
    out_num   = num.fft.fftn(Z_num, axes=[2])
    assert allclose(out, out_num)
    out       = np.fft.fftn(Z, axes=[-1])
    out_num   = num.fft.fftn(Z_num, axes=[-1])
    assert allclose(out, out_num)
    out       = np.fft.fftn(Z, axes=[-2])
    out_num   = num.fft.fftn(Z_num, axes=[-2])
    assert allclose(out, out_num)
    out       = np.fft.fftn(Z, axes=[-3])
    out_num   = num.fft.fftn(Z_num, axes=[-3])
    assert allclose(out, out_num)
    out       = np.fft.fftn(Z, axes=[2, 1])
    out_num   = num.fft.fftn(Z_num, axes=[2, 1])
    assert allclose(out, out_num)
    out       = np.fft.fftn(Z, axes=[0, 2])
    out_num   = num.fft.fftn(Z_num, axes=[0, 2])
    assert allclose(out, out_num)
    out       = np.fft.fftn(Z, axes=[0, 2, 1, 1, -1])
    out_num   = num.fft.fftn(Z_num, axes=[0, 2, 1, 1, -1])
    assert allclose(out, out_num)
    out       = np.fft.ifftn(Z)
    out_num   = num.fft.ifftn(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.ifftn(Z, norm='forward')
    out_num   = num.fft.ifftn(Z_num, norm='forward')
    assert allclose(out, out_num)
    out       = np.fft.ifftn(Z, norm='ortho')
    out_num   = num.fft.ifftn(Z_num, norm='ortho')
    assert allclose(out, out_num)
    out       = np.fft.ifftn(Z, s=(63,20,99))
    out_num   = num.fft.ifftn(Z_num, s=(63,20,99))
    assert allclose(out, out_num)
    out       = np.fft.ifftn(Z, s=(65,43,109))
    out_num   = num.fft.ifftn(Z_num, s=(65,43,109))
    assert allclose(out, out_num)
    out       = np.fft.ifftn(Z, axes=[0])
    out_num   = num.fft.ifftn(Z_num, axes=[0])
    assert allclose(out, out_num)
    out       = np.fft.ifftn(Z, axes=[1])
    out_num   = num.fft.ifftn(Z_num, axes=[1])
    assert allclose(out, out_num)
    out       = np.fft.ifftn(Z, axes=[2])
    out_num   = num.fft.ifftn(Z_num, axes=[2])
    assert allclose(out, out_num)
    out       = np.fft.ifftn(Z, axes=[-1])
    out_num   = num.fft.ifftn(Z_num, axes=[-1])
    assert allclose(out, out_num)
    out       = np.fft.ifftn(Z, axes=[-2])
    out_num   = num.fft.ifftn(Z_num, axes=[-2])
    assert allclose(out, out_num)
    out       = np.fft.ifftn(Z, axes=[-3])
    out_num   = num.fft.ifftn(Z_num, axes=[-3])
    assert allclose(out, out_num)
    out       = np.fft.ifftn(Z, axes=[2, 1])
    out_num   = num.fft.ifftn(Z_num, axes=[2, 1])
    assert allclose(out, out_num)
    out       = np.fft.ifftn(Z, axes=[0, 2])
    out_num   = num.fft.ifftn(Z_num, axes=[0, 2])
    assert allclose(out, out_num)
    out       = np.fft.ifftn(Z, axes=[0, 2, 1, 1, -1])
    out_num   = num.fft.ifftn(Z_num, axes=[0, 2, 1, 1, -1])
    assert allclose(out, out_num)
    # Odd types
    out       = np.fft.rfftn(Z)
    out_num   = num.fft.rfftn(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.ihfft(Z)
    out_num   = num.fft.ihfft(Z_num)
    assert allclose(out, out_num)
    assert allclose(Z, Z_num)

def test_1d_r2c(dtype=np.float64):
    Z     = np.random.rand(1000001).astype(dtype)
    Z_num = num.array(Z)

    out       = np.fft.rfft(Z)
    out_num   = num.fft.rfft(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.rfft(Z, norm='forward')
    out_num   = num.fft.rfft(Z_num, norm='forward')
    assert allclose(out, out_num)
    out       = np.fft.rfft(Z, n=5001)
    out_num   = num.fft.rfft(Z_num, n=5001)
    assert allclose(out, out_num)
    out       = np.fft.rfft(Z, n=500)
    out_num   = num.fft.rfft(Z_num, n=500)
    assert allclose(out, out_num)
    out       = np.fft.rfft(Z, n=1100)
    out_num   = num.fft.rfft(Z_num, n=1100)
    assert allclose(out, out_num)
    out       = np.fft.rfft(Z, n=1001001)
    out_num   = num.fft.rfft(Z_num, n=1001001)
    assert allclose(out, out_num)
    # Odd types
    out       = np.fft.irfft(Z)
    out_num   = num.fft.irfft(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.hfft(Z)
    out_num   = num.fft.hfft(Z_num)
    assert allclose(out, out_num)
    assert allclose(Z, Z_num)

def test_2d_r2c(dtype=np.float64):
    Z     = np.random.rand(128, 1024).astype(dtype)
    Z_num = num.array(Z)

    out       = np.fft.rfft2(Z)
    out_num   = num.fft.rfft2(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.rfft2(Z, norm='forward')
    out_num   = num.fft.rfft2(Z_num, norm='forward')
    assert allclose(out, out_num)
    out       = np.fft.rfft2(Z,  s=(64,512))
    out_num   = num.fft.rfft2(Z_num, s=(64,512))
    assert allclose(out, out_num)
    out       = np.fft.rfft2(Z,  s=(129,1030))
    out_num   = num.fft.rfft2(Z_num, s=(129,1030))
    assert allclose(out, out_num)
    out       = np.fft.rfft2(Z,  s=(29,1030))
    out_num   = num.fft.rfft2(Z_num, s=(29,1030))
    assert allclose(out, out_num)
    out       = np.fft.rfft2(Z, axes=[0])
    out_num   = num.fft.rfft2(Z_num, axes=[0])
    assert allclose(out, out_num)
    out       = np.fft.rfft2(Z, axes=[1])
    out_num   = num.fft.rfft2(Z_num, axes=[1])
    assert allclose(out, out_num)
    out       = np.fft.rfft2(Z, axes=[-1])
    out_num   = num.fft.rfft2(Z_num, axes=[-1])
    assert allclose(out, out_num)
    out       = np.fft.rfft2(Z, axes=[-2])
    out_num   = num.fft.rfft2(Z_num, axes=[-2])
    assert allclose(out, out_num)
    out       = np.fft.rfft2(Z, axes=[0, 1])
    out_num   = num.fft.rfft2(Z_num, axes=[0, 1])
    assert allclose(out, out_num)
    out       = np.fft.rfft2(Z, axes=[1, 0])
    out_num   = num.fft.rfft2(Z_num, axes=[1, 0])
    assert allclose(out, out_num)
    out       = np.fft.rfft2(Z, axes=[1, 0, 1])
    out_num   = num.fft.rfft2(Z_num, axes=[1, 0, 1])
    assert allclose(out, out_num)
    # Odd types
    out       = np.fft.irfft2(Z)
    out_num   = num.fft.irfft2(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.hfft(Z)
    out_num   = num.fft.hfft(Z_num)
    assert allclose(out, out_num)
    assert allclose(Z, Z_num)

def test_3d_r2c(dtype=np.float64):
    Z     = np.random.rand(64, 40, 100).astype(dtype)
    Z_num = num.array(Z)

    out       = np.fft.rfftn(Z)
    out_num   = num.fft.rfftn(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.rfftn(Z, norm='forward')
    out_num   = num.fft.rfftn(Z_num, norm='forward')
    assert allclose(out, out_num)
    out       = np.fft.rfftn(Z, norm='ortho')
    out_num   = num.fft.rfftn(Z_num, norm='ortho')
    assert allclose(out, out_num)
    out       = np.fft.rfftn(Z, s=(63,20,99))
    out_num   = num.fft.rfftn(Z_num, s=(63,20,99))
    assert allclose(out, out_num)
    out       = np.fft.rfftn(Z, s=(65,43,109))
    out_num   = num.fft.rfftn(Z_num, s=(65,43,109))
    assert allclose(out, out_num)
    out       = np.fft.rfftn(Z, axes=[0])
    out_num   = num.fft.rfftn(Z_num, axes=[0])
    assert allclose(out, out_num)
    out       = np.fft.rfftn(Z, axes=[1])
    out_num   = num.fft.rfftn(Z_num, axes=[1])
    assert allclose(out, out_num)
    out       = np.fft.rfftn(Z, axes=[2])
    out_num   = num.fft.rfftn(Z_num, axes=[2])
    assert allclose(out, out_num)
    out       = np.fft.rfftn(Z, axes=[-1])
    out_num   = num.fft.rfftn(Z_num, axes=[-1])
    assert allclose(out, out_num)
    out       = np.fft.rfftn(Z, axes=[-2])
    out_num   = num.fft.rfftn(Z_num, axes=[-2])
    assert allclose(out, out_num)
    out       = np.fft.rfftn(Z, axes=[-3])
    out_num   = num.fft.rfftn(Z_num, axes=[-3])
    assert allclose(out, out_num)
    out       = np.fft.rfftn(Z, axes=[2, 1])
    out_num   = num.fft.rfftn(Z_num, axes=[2, 1])
    assert allclose(out, out_num)
    out       = np.fft.rfftn(Z, axes=[0, 2])
    out_num   = num.fft.rfftn(Z_num, axes=[0, 2])
    assert allclose(out, out_num)
    out       = np.fft.rfftn(Z, axes=[0, 2, 1, 1, -1])
    out_num   = num.fft.rfftn(Z_num, axes=[0, 2, 1, 1, -1])
    assert allclose(out, out_num)
    # Odd types
    out       = np.fft.fftn(Z)
    out_num   = num.fft.fftn(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.ifftn(Z)
    out_num   = num.fft.ifftn(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.irfftn(Z)
    out_num   = num.fft.irfftn(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.hfft(Z)
    out_num   = num.fft.hfft(Z_num)
    assert allclose(out, out_num)
    assert allclose(Z, Z_num)

def test_1d_c2r(dtype=np.float64):
    Z     = np.random.rand(1000001).astype(dtype) + np.random.rand(1000001).astype(dtype) * 1j
    Z_num = num.array(Z)

    out       = np.fft.irfft(Z)
    out_num   = num.fft.irfft(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.irfft(Z, norm='forward')
    out_num   = num.fft.irfft(Z_num, norm='forward')
    assert allclose(out, out_num)
    out       = np.fft.irfft(Z, n=51)
    out_num   = num.fft.irfft(Z_num, n=51)
    assert allclose(out, out_num)
    out       = np.fft.irfft(Z, n=500)
    out_num   = num.fft.irfft(Z_num, n=500)
    assert allclose(out, out_num)
    out       = np.fft.irfft(Z, n=1100)
    out_num   = num.fft.irfft(Z_num, n=1100)
    assert allclose(out, out_num)
    out       = np.fft.irfft(Z, n=1001001)
    out_num   = num.fft.irfft(Z_num, n=1001001)
    assert allclose(out, out_num)
    # Odd types
    out       = np.fft.rfft(Z)
    out_num   = num.fft.rfft(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.ihfft(Z)
    out_num   = num.fft.ihfft(Z_num)
    assert allclose(out, out_num)
    assert allclose(Z, Z_num)

def test_2d_c2r(dtype=np.float64):
    Z     = np.random.rand(128, 1024).astype(dtype) + np.random.rand(128, 1024).astype(dtype) * 1j
    Z_num = num.array(Z)

    out       = np.fft.irfft2(Z)
    out_num   = num.fft.irfft2(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.irfft2(Z, norm='forward')
    out_num   = num.fft.irfft2(Z_num, norm='forward')
    assert allclose(out, out_num)
    out       = np.fft.irfft2(Z,  s=(64,512))
    out_num   = num.fft.irfft2(Z_num, s=(64,512))
    assert allclose(out, out_num)
    out       = np.fft.irfft2(Z,  s=(129,1030))
    out_num   = num.fft.irfft2(Z_num, s=(129,1030))
    assert allclose(out, out_num)
    out       = np.fft.irfft2(Z,  s=(29,1030))
    out_num   = num.fft.irfft2(Z_num, s=(29,1030))
    assert allclose(out, out_num)
    out       = np.fft.irfft2(Z, axes=[0])
    out_num   = num.fft.irfft2(Z_num, axes=[0])
    assert allclose(out, out_num)
    out       = np.fft.irfft2(Z, axes=[1])
    out_num   = num.fft.irfft2(Z_num, axes=[1])
    assert allclose(out, out_num)
    out       = np.fft.irfft2(Z, axes=[-1])
    out_num   = num.fft.irfft2(Z_num, axes=[-1])
    assert allclose(out, out_num)
    out       = np.fft.irfft2(Z, axes=[-2])
    out_num   = num.fft.irfft2(Z_num, axes=[-2])
    assert allclose(out, out_num)
    out       = np.fft.irfft2(Z, axes=[0, 1])
    out_num   = num.fft.irfft2(Z_num, axes=[0, 1])
    assert allclose(out, out_num)
    out       = np.fft.irfft2(Z, axes=[1, 0])
    out_num   = num.fft.irfft2(Z_num, axes=[1, 0])
    assert allclose(out, out_num)
    out       = np.fft.irfft2(Z, axes=[1, 0, 1])
    out_num   = num.fft.irfft2(Z_num, axes=[1, 0, 1])
    assert allclose(out, out_num)
    # Odd types
    out       = np.fft.rfft2(Z)
    out_num   = num.fft.rfft2(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.ihfft(Z)
    out_num   = num.fft.ihfft(Z_num)
    assert allclose(out, out_num)
    assert allclose(Z, Z_num)

def test_3d_c2r(dtype=np.float64):
    Z     = np.random.rand(32, 40, 85).astype(dtype) + np.random.rand(32, 40, 85).astype(dtype) * 1j
    Z_num = num.array(Z)

    out       = np.fft.irfftn(Z)
    out_num   = num.fft.irfftn(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.irfftn(Z, norm='forward')
    out_num   = num.fft.irfftn(Z_num, norm='forward')
    assert allclose(out, out_num)
    out       = np.fft.irfftn(Z, norm='ortho')
    out_num   = num.fft.irfftn(Z_num, norm='ortho')
    assert allclose(out, out_num)
    out       = np.fft.irfftn(Z, s=(31,20,79))
    out_num   = num.fft.irfftn(Z_num, s=(31,20,79))
    assert allclose(out, out_num)
    out       = np.fft.irfftn(Z, s=(35,43,90))
    out_num   = num.fft.irfftn(Z_num, s=(35,43,90))
    assert allclose(out, out_num)
    out       = np.fft.irfftn(Z, axes=[0])
    out_num   = num.fft.irfftn(Z_num, axes=[0])
    assert allclose(out, out_num)
    out       = np.fft.irfftn(Z, axes=[1])
    out_num   = num.fft.irfftn(Z_num, axes=[1])
    assert allclose(out, out_num)
    out       = np.fft.irfftn(Z, axes=[2])
    out_num   = num.fft.irfftn(Z_num, axes=[2])
    assert allclose(out, out_num)
    out       = np.fft.irfftn(Z, axes=[-1])
    out_num   = num.fft.irfftn(Z_num, axes=[-1])
    assert allclose(out, out_num)
    out       = np.fft.irfftn(Z, axes=[-2])
    out_num   = num.fft.irfftn(Z_num, axes=[-2])
    assert allclose(out, out_num)
    out       = np.fft.irfftn(Z, axes=[-3])
    out_num   = num.fft.irfftn(Z_num, axes=[-3])
    assert allclose(out, out_num)
    out       = np.fft.irfftn(Z, axes=[2, 1])
    out_num   = num.fft.irfftn(Z_num, axes=[2, 1])
    assert allclose(out, out_num)
    out       = np.fft.irfftn(Z, axes=[0, 2])
    out_num   = num.fft.irfftn(Z_num, axes=[0, 2])
    assert allclose(out, out_num)
    out       = np.fft.irfftn(Z, axes=[0, 2, 1, 1, -1])
    out_num   = num.fft.irfftn(Z_num, axes=[0, 2, 1, 1, -1])
    assert allclose(out, out_num)
    # Odd types
    out       = np.fft.rfftn(Z)
    out_num   = num.fft.rfftn(Z_num)
    assert allclose(out, out_num)
    out       = np.fft.ihfft(Z)
    out_num   = num.fft.ihfft(Z_num)
    assert allclose(out, out_num)
    assert allclose(Z, Z_num)

def test_1d_hfft(dtype=np.float64):
    Z     = np.random.rand(1000).astype(dtype) + np.random.rand(1000).astype(dtype) * 1j
    Z_num = num.array(Z)

    out       = np.fft.hfft(Z)
    out_num   = num.fft.hfft(Z_num)
    assert allclose(out, out_num)
    assert allclose(Z, Z_num)

def test_1d_hfft_inverse(dtype=np.float64):
    Z     = np.random.rand(1000).astype(dtype)
    Z_num = num.array(Z)

    out       = np.fft.ihfft(Z)
    out_num   = num.fft.ihfft(Z_num)
    assert allclose(out, out_num)
    assert allclose(Z, Z_num)

if __name__ == "__main__":
    # Keep errors reproducible
    np.random.seed(0)
    print('=== 1D double                   ===')
    test_1d()
    print('=== 1D float                    ===')
    test_1d(np.float32)
    print('=== 2D double                   ===')
    test_2d()
    print('=== 2D float                    ===')
    test_2d(np.float32)
    print('=== 3D double                   ===')
    test_3d()
    print('=== 3D float                    ===')
    test_3d(np.float32)
    print('=== 1D R2C double               ===')
    test_1d_r2c()
    print('=== 1D R2C float                ===')
    test_1d_r2c(np.float32)
    print('=== 2D R2C double               ===')
    test_2d_r2c()
    print('=== 2D R2C float                ===')
    test_2d_r2c(np.float32)
    print('=== 3D R2C double               ===')
    test_3d_r2c()
    print('=== 3D R2C float                ===')
    test_3d_r2c(np.float32)
    print('=== 1D C2R double               ===')
    test_1d_c2r()
    print('=== 1D C2R float                ===')
    test_1d_c2r(np.float32)
    print('=== 2D C2R double               ===')
    test_2d_c2r()
    print('=== 2D C2R float                ===')
    test_2d_c2r(np.float32)
    print('=== 3D C2R double               ===')
    test_3d_c2r()
    print('=== 3D C2R float                ===')
    test_3d_c2r(np.float32)
    print('=== 1D Hermitian double         ===')
    test_1d_hfft()
    print('=== 1D Hermitian float          ===')
    test_1d_hfft(np.float32)
    print('=== 1D Hermitian inverse double ===')
    test_1d_hfft_inverse()
    print('=== 1D Hermitian inverse float  ===')
    test_1d_hfft_inverse(np.float32)
